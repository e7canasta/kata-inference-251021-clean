# üéØ PLAN DE QUICK WINS - ADELINE v3.0

**Basado en**: INFORME_CONSULTORIA_DISENIO.md
**Objetivo**: Implementar mejoras de alto impacto con bajo esfuerzo
**Filosof√≠a**: "Complejidad por dise√±o" + Pragmatismo > Purismo

---

## üìä MATRIZ DE PRIORIZACI√ìN

```
         ‚îÇ Alto Impacto       ‚îÇ Medio Impacto      ‚îÇ Bajo Impacto
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Bajo     ‚îÇ ‚úÖ QUICK WINS      ‚îÇ ‚ö° Considerar      ‚îÇ üìù Backlog
Esfuerzo ‚îÇ (Hacer ahora)      ‚îÇ (Si hay tiempo)    ‚îÇ (Futuro)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Alto     ‚îÇ üéØ Planificar      ‚îÇ ‚è∏Ô∏è Postponer       ‚îÇ ‚ùå No hacer
Esfuerzo ‚îÇ (Sprint dedicado)  ‚îÇ (Bajo ROI)         ‚îÇ (YAGNI)
```

---

## ‚úÖ QUICK WINS - SPRINT ACTUAL (2-3 d√≠as)

### üîß C√ìDIGO - Quick Wins

#### 1. **Fix Type Hints con TYPE_CHECKING** üü° [30 min]

**Archivo**: `app/builder.py`

**Problema actual**:
```python
def build_sinks(
    self,
    data_plane: Any,  # ‚Üê Type hint d√©bil
    roi_state: Optional[Any] = None,
    inference_handler: Optional[BaseInferenceHandler] = None,
) -> List[Callable]:
```

**Soluci√≥n**:
```python
from typing import TYPE_CHECKING, Optional, List, Callable, Union

if TYPE_CHECKING:
    from ..data import MQTTDataPlane
    from ..inference.roi import ROIState, FixedROIState

def build_sinks(
    self,
    data_plane: 'MQTTDataPlane',
    roi_state: Optional[Union['ROIState', 'FixedROIState']] = None,
    inference_handler: Optional[BaseInferenceHandler] = None,
) -> List[Callable]:
```

**Beneficios**:
- ‚úÖ Mypy validation completa
- ‚úÖ IDE autocomplete
- ‚úÖ Sin costo en runtime
- ‚úÖ Patr√≥n est√°ndar Python

**Archivos a modificar**:
- `app/builder.py` (l√≠neas 88-93)
- Verificar otros `Any` en codebase con: `grep -n "data_plane: Any" **/*.py`

---

#### 2. **Best-Effort Cleanup con Error Handling** üü¢ [45 min]

**Archivo**: `app/controller.py`

**Problema actual** (l√≠neas 398-443):
```python
def cleanup(self):
    if self.pipeline:
        self.pipeline.terminate()
        self.pipeline.join(timeout=10.0)

    if self.control_plane:
        self.control_plane.disconnect()  # Si falla, data_plane no se desconecta

    if self.data_plane:
        stats = self.data_plane.get_stats()
        self.data_plane.disconnect()
```

**Soluci√≥n**:
```python
def cleanup(self):
    """Cleanup con best-effort error handling"""
    errors = []

    # 1. Terminate pipeline (independiente)
    if self.pipeline:
        try:
            logger.info("Terminating pipeline...")
            self.pipeline.terminate()
            self.pipeline.join(timeout=10.0)
            logger.info("Pipeline terminated successfully")
        except Exception as e:
            errors.append(f"Pipeline cleanup: {e}")
            logger.error("Pipeline cleanup error", exc_info=True)

    # 2. Disconnect control plane (independiente)
    if self.control_plane:
        try:
            logger.info("Disconnecting control plane...")
            self.control_plane.publish_status("disconnected")
            self.control_plane.disconnect()
            logger.info("Control plane disconnected")
        except Exception as e:
            errors.append(f"Control plane disconnect: {e}")
            logger.error("Control plane cleanup error", exc_info=True)

    # 3. Disconnect data plane (independiente)
    if self.data_plane:
        try:
            logger.info("Disconnecting data plane...")
            stats = self.data_plane.get_stats()
            logger.info(f"Data plane stats: {stats}")
            self.data_plane.disconnect()
            logger.info("Data plane disconnected")
        except Exception as e:
            errors.append(f"Data plane disconnect: {e}")
            logger.error("Data plane cleanup error", exc_info=True)

    # Summary
    if errors:
        logger.warning(
            f"Cleanup completed with {len(errors)} errors",
            extra={"errors": errors, "component": "controller", "event": "cleanup_partial"}
        )
    else:
        logger.info(
            "Cleanup completed successfully",
            extra={"component": "controller", "event": "cleanup_complete"}
        )
```

**Beneficios**:
- ‚úÖ Cleanup garantizado (best-effort)
- ‚úÖ No cascade failures
- ‚úÖ Logging estructurado de errores
- ‚úÖ M√°s robusto en producci√≥n

**Test manual**:
1. Killear MQTT broker mientras pipeline corre
2. Hacer Ctrl+C
3. Verificar que cleanup completo se ejecute aunque broker est√© ca√≠do

---

#### 3. **Health Check Endpoint** üü¢ [1 hora]

**Archivos**: `app/controller.py`, `control/plane.py`

**Implementaci√≥n**:

```python
# En app/controller.py, agregar m√©todo:

def _handle_health_check(self):
    """
    Health check multi-nivel para monitoring externo.

    Status:
    - healthy: Todos los checks pasan
    - degraded: Algunos checks fallan pero core funciona
    - unhealthy: Checks cr√≠ticos fallan
    """
    health = {
        'status': 'healthy',
        'timestamp': time.time(),
        'version': '3.0.0',  # TODO: Read from __version__
        'checks': {
            # Critical checks
            'pipeline_running': self.pipeline and self.pipeline.is_alive(),
            'control_plane_connected': self.control_plane and self.control_plane.is_connected(),
            'data_plane_connected': self.data_plane and self.data_plane.is_connected(),

            # Health checks
            'recent_frames': self.watchdog.get_frames_in_last_n_seconds(30) > 0,
            'avg_fps': self.watchdog.get_average_fps(),
        }
    }

    # Determine overall status
    critical_checks = [
        health['checks']['pipeline_running'],
        health['checks']['control_plane_connected'],
        health['checks']['data_plane_connected'],
    ]

    if all(critical_checks) and health['checks']['recent_frames']:
        health['status'] = 'healthy'
    elif any(critical_checks):
        health['status'] = 'degraded'
    else:
        health['status'] = 'unhealthy'

    # Publish
    self.control_plane.publish_status(json.dumps(health))
    logger.info(
        f"Health check: {health['status']}",
        extra={
            "component": "controller",
            "event": "health_check",
            "status": health['status'],
            "checks": health['checks']
        }
    )

# En _setup_control_callbacks(), agregar:
registry.register('health', self._handle_health_check, "Health check del sistema")
```

**Test**:
```bash
# Publicar health check command
mosquitto_pub -t "inference/control/commands" -m '{"command": "health"}'

# Escuchar respuesta
mosquitto_sub -t "inference/control/status" -v
```

**Beneficios**:
- ‚úÖ K8s/Docker health probes
- ‚úÖ Monitoring externo (Grafana, etc)
- ‚úÖ Debugging de problemas en producci√≥n

---

### üìù WIKI - Quick Wins

#### 4. **Aclarar ROI Square Constraint** üìÑ [15 min]

**Archivo**: `docs/wiki/1  Overview/1.1  Core Concepts.md`

**Cambio** (l√≠nea 76):

**Antes**:
```markdown
- **Square constraint**: Adaptive ROI maintains square aspect ratio to prevent model distortion
```

**Despu√©s**:
```markdown
- **Square constraint**: Adaptive ROI maintains square aspect ratio to prevent model distortion.
  Square sides are multiples of configurable values (`min_roi_multiple`, `max_roi_multiple`),
  not necessarily `imgsz`. Default: 320-640 pixels for 320x320 model.
```

---

#### 5. **Documentar Sink Priority Values** üìÑ [10 min]

**Archivo**: `docs/wiki/5  Inference Pipeline/5.4 Output-Sinks.md`

**Agregar secci√≥n**:

```markdown
### Sink Priority System

Sinks are registered with explicit priority values to control execution order:

| Priority | Sink Type | Purpose | Critical for Stabilization? |
|----------|-----------|---------|----------------------------|
| **1** | MQTT Sink | Publish detections to MQTT broker | ‚úÖ Yes - wrapped by stabilizer |
| **50** | ROI Update Sink | Update adaptive ROI state | ‚ùå No |
| **100** | Visualization Sink | OpenCV display window | ‚ùå No |

**Important**: The stabilization wrapper assumes the MQTT sink is first (priority 1).
Changing sink priorities requires updating `PipelineBuilder.wrap_sinks_with_stabilization()`.

See: `app/factories/sink_factory.py:131-148`
```

---

#### 6. **Documentar Health Check Command** üìÑ [20 min]

**Archivo**: `docs/wiki/4  MQTT Communication/4.3  Command Reference.md`

**Agregar secci√≥n**:

```markdown
### `health` - System Health Check

**Description**: Returns multi-level health status for external monitoring.

**Availability**: Always

**Request**:
```json
{
  "command": "health",
  "timestamp": "2025-10-23T12:00:00Z"
}
```

**Response** (via `inference/control/status` topic):
```json
{
  "status": "healthy",  // "healthy" | "degraded" | "unhealthy"
  "timestamp": 1698062400.0,
  "version": "3.0.0",
  "checks": {
    "pipeline_running": true,
    "control_plane_connected": true,
    "data_plane_connected": true,
    "recent_frames": true,
    "avg_fps": 2.1
  }
}
```

**Status Levels**:
- `healthy`: All critical checks pass, pipeline is processing frames
- `degraded`: Some non-critical checks fail but pipeline is operational
- `unhealthy`: Critical checks fail (pipeline stopped, MQTT disconnected)

**Use Cases**:
- Kubernetes liveness/readiness probes
- Grafana alerting rules
- External monitoring dashboards
- CI/CD health verification
```

---

## ‚ö° CONSIDERAR SI HAY TIEMPO (1-2 d√≠as)

### 7. **Refactor Stabilization Wrapping para ser Expl√≠cito** üü° [2 horas]

**Archivo**: `app/builder.py`

**Problema**: Asume que `sinks[0]` es MQTT sink basado en priority impl√≠cito.

**Opci√≥n A - Buscar por nombre** (M√°s simple):

```python
def wrap_sinks_with_stabilization(self, sinks: List[Callable]) -> List[Callable]:
    """
    Wrappea MQTT sink con stabilization.

    Note:
        Busca expl√≠citamente el MQTT sink por nombre en lugar de asumir posici√≥n.
    """
    if self.config.STABILIZATION_MODE == 'none':
        self.stabilizer = None
        return sinks

    # Buscar MQTT sink expl√≠citamente
    mqtt_sink_idx = None
    for i, sink in enumerate(sinks):
        # MQTT sink tiene __name__ == 'mqtt_sink' (set by create_mqtt_sink)
        if hasattr(sink, '__name__') and 'mqtt' in sink.__name__.lower():
            mqtt_sink_idx = i
            break

    if mqtt_sink_idx is None:
        raise ValueError(
            "No MQTT sink found to wrap with stabilization. "
            "Ensure SinkFactory creates MQTT sink with recognizable name."
        )

    logger.info(f"Found MQTT sink at index {mqtt_sink_idx}")

    from ..inference.stabilization import create_stabilization_sink

    # Crear stabilizer
    self.stabilizer = StrategyFactory.create_stabilization_strategy(self.config)

    # Wrap MQTT sink
    mqtt_sink = sinks[mqtt_sink_idx]
    stabilized_sink = create_stabilization_sink(
        stabilizer=self.stabilizer,
        downstream_sink=mqtt_sink,
    )

    # Reconstruir lista (immutable)
    new_sinks = (
        sinks[:mqtt_sink_idx] +
        [stabilized_sink] +
        sinks[mqtt_sink_idx+1:]
    )

    logger.info(
        "Stabilization wrapper complete",
        extra={
            "component": "builder",
            "event": "stabilization_wrap_complete",
            "stabilization_mode": self.config.STABILIZATION_MODE,
            "mqtt_sink_index": mqtt_sink_idx
        }
    )
    return new_sinks
```

**Cambio en** `data/publishers.py` (agregar `__name__`):

```python
def create_mqtt_sink(data_plane: MQTTDataPlane) -> Callable:
    """Factory para MQTT sink"""
    def mqtt_sink(predictions, video_frame):
        data_plane.publish_detection(predictions, video_frame)

    mqtt_sink.__name__ = 'mqtt_sink'  # ‚Üê Agregar esto
    return mqtt_sink
```

**Beneficios**:
- ‚úÖ Expl√≠cito en lugar de impl√≠cito
- ‚úÖ Fail-fast si MQTT sink no existe
- ‚úÖ Robusto ante cambios de priority

**Test**:
- Cambiar priority de MQTT sink a 10
- Verificar que stabilization sigue funcionando

---

### 8. **Agregar `__version__` al Package** üìÑ [30 min]

**Archivo**: `adeline/__init__.py`

**Agregar**:
```python
"""
Adeline Inference Pipeline
==========================

Fall detection system for geriatric residences.
"""

__version__ = "3.0.0"
__author__ = "Visiona Team"

# Re-exports para API p√∫blica
from .config import PipelineConfig, AdelineConfig

__all__ = [
    '__version__',
    'PipelineConfig',
    'AdelineConfig',
]
```

**Uso en health check**:
```python
from adeline import __version__

health['version'] = __version__
```

---

## üéØ PLANIFICAR PARA SPRINT SIGUIENTE (3-5 d√≠as)

### 9. **Event Sourcing para Stabilization** üöÄ [3-4 d√≠as]

**Descripci√≥n**: Ver INFORME_CONSULTORIA_DISENIO.md, Parte 3, secci√≥n "Event Sourcing"

**Criterio de decisi√≥n**:
- ‚úÖ Implementar SI debugging de stabilization se vuelve dif√≠cil
- ‚úÖ Implementar SI necesitamos audit trail para compliance
- ‚ùå POSTPONER si stabilization actual funciona bien

**Archivos nuevos**:
- `inference/stabilization/events.py` - Event classes
- `inference/stabilization/event_sourced.py` - EventSourcedStabilizer
- `tests/test_event_sourcing.py` - Tests

---

### 10. **Structured Metrics Collector** üìä [2-3 d√≠as]

**Descripci√≥n**: Ver INFORME_CONSULTORIA_DISENIO.md, Parte 3, secci√≥n "Structured Metrics"

**Archivos nuevos**:
- `metrics/__init__.py`
- `metrics/collector.py` - MetricsCollector class
- `metrics/exporters.py` - Prometheus/JSON exporters

**Integraci√≥n**:
- Controller registra m√©tricas en cada frame
- MQTT command `metrics_export` retorna formato Prometheus

---

## üìù BACKLOG - NO URGENTE

### 11. **Factory Instances en lugar de Static Methods** üü¢ [2 d√≠as]

**Trigger**: SOLO si necesitamos:
- Dependency injection en factories
- Cachear resultados de creaci√≥n
- Mockear factories en tests

**Recomendaci√≥n**: Dejar como est√° hasta que necesitemos estas features.

---

### 12. **Protocol Types para todas las interfaces** üü° [3 d√≠as]

**Trigger**: Si mypy strict mode se activa en todo el proyecto

**Archivos**:
- `app/protocols.py` - Definir todos los Protocols
- Refactor gradual de `Any` types

---

## üìã CHECKLIST DE IMPLEMENTACI√ìN

### Sprint Actual - Quick Wins

- [ ] **C√≥digo**
  - [ ] Fix type hints con `TYPE_CHECKING` (app/builder.py)
  - [ ] Best-effort cleanup con try/except (app/controller.py)
  - [ ] Health check endpoint (app/controller.py, control/registry.py)
  - [ ] Agregar `__name__` a mqtt_sink (data/publishers.py)

- [ ] **Wiki**
  - [ ] Aclarar ROI square constraint (1.1  Core Concepts.md)
  - [ ] Documentar sink priority values (5.4 Output-Sinks.md)
  - [ ] Documentar health check command (4.3  Command Reference.md)

- [ ] **Testing**
  - [ ] Test manual de cleanup con broker ca√≠do
  - [ ] Test health check via mosquitto
  - [ ] Compilar con mypy despu√©s de type hints
  - [ ] Run test suite completo: `pytest -v`

### Sprint Siguiente - Planificado

- [ ] **C√≥digo**
  - [ ] Refactor stabilization wrapping expl√≠cito
  - [ ] Agregar `__version__` al package
  - [ ] (Condicional) Event sourcing si debugging lo amerita
  - [ ] (Condicional) Structured metrics si se necesita Prometheus

---

## üé∏ FILOSOF√çA DE IMPLEMENTACI√ìN

**Pragmatismo > Purismo**:
- ‚úÖ Implementar quick wins que agregan valor inmediato
- ‚úÖ Postponer features "nice-to-have" hasta que sean necesarias
- ‚úÖ Testing manual para quick wins, automated tests para features grandes

**"El diablo sabe por diablo, no por viejo"**:
- Los patterns aplicados tienen prop√≥sito claro
- No sobre-dise√±ar soluciones a problemas que no tenemos
- YAGNI aplicado rigurosamente

**"Complejidad por dise√±o, no por accidente"**:
- Type hints mejoran dise√±o (contrato claro)
- Error handling previene complejidad accidental (bugs sutiles)
- Health check es dise√±o intencional (observability)

---

## üìä M√âTRICAS DE √âXITO

**Quick Wins implementados**:
- ‚úÖ Mypy pasa sin errores en `app/builder.py`
- ‚úÖ Cleanup funciona aunque broker est√© ca√≠do
- ‚úÖ Health check responde correctamente
- ‚úÖ Wiki sincronizada con c√≥digo (100%)

**Timeline**:
- D√≠a 1: Items 1-3 (c√≥digo)
- D√≠a 2: Items 4-6 (wiki) + testing
- D√≠a 3: (Opcional) Items 7-8 si hay tiempo

**Owner**: Ernesto + Gaby (pair programming)

---

## üöÄ SIGUIENTE SESI√ìN

**Prioridad 1**: Implementar Quick Wins 1-3 (c√≥digo)
**Prioridad 2**: Actualizar wiki (4-6)
**Prioridad 3**: Testing manual

¬øArrancamos con type hints? üé∏
