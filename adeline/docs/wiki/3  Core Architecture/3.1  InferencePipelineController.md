# InferencePipelineController

Relevant source files

- [adeline/CLAUDE.md](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md)
- [adeline/app/controller.py](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py)
- [adeline/control/plane.py](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/control/plane.py)
- [adeline/control/registry.py](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/control/registry.py)

The `InferencePipelineController` is the main orchestrator for the Adeline inference pipeline system. It manages the complete lifecycle of the video processing pipeline, coordinates MQTT communication planes, and handles graceful startup and shutdown procedures.

**Scope**: This page covers the controller's orchestration responsibilities, setup process, lifecycle management, and signal handling. For details on how components are constructed, see [PipelineBuilder](https://deepwiki.com/acare7/kata-inference-251021-clean4/3.2-pipelinebuilder). For MQTT command handling details, see [Control Plane](https://deepwiki.com/acare7/kata-inference-251021-clean4/4.1-control-plane) and [Data Plane](https://deepwiki.com/acare7/kata-inference-251021-clean4/4.2-data-plane). For inference handler specifics, see [ROI Strategies](https://deepwiki.com/acare7/kata-inference-251021-clean4/5.1-roi-strategies).

## Core Responsibilities

The `InferencePipelineController` class implements the following responsibilities:

|Responsibility|Description|
|---|---|
|**Orchestration**|Coordinates setup of Control Plane, Data Plane, and InferencePipeline components|
|**Lifecycle Management**|Handles start, stop, pause, resume operations via MQTT commands|
|**Delegation**|Delegates component construction to `PipelineBuilder`, maintaining separation of concerns|
|**Signal Handling**|Intercepts SIGINT (Ctrl+C) and SIGTERM for graceful shutdown|
|**Resource Cleanup**|Ensures proper disconnection and resource release on termination|
|**Command Registration**|Conditionally registers MQTT commands based on system capabilities|

**Design Philosophy**: The controller follows the Single Responsibility Principle by orchestrating component interactions without knowing construction details. It delegates all component building to `PipelineBuilder` [adeline/app/controller.py75](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L75-L75)

Sources: [adeline/app/controller.py58-71](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L58-L71) [adeline/CLAUDE.md65-88](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md#L65-L88)

## Controller Architecture



```mermaid
flowchart TB

subgraph "InferencePipelineController"
  %% --- Lifecycle Methods ---
  subgraph "Lifecycle Methods"
    CONFIG["PipelineConfig"]
    INIT["init(config)"]
    SETUP["setup()"]
    RUN["run()"]
    CLEANUP["cleanup()"]
  end

  %% --- Managed Components ---
  subgraph "Managed Components"
    DATA["data_plane: MQTTDataPlane"]
    CONTROL["control_plane: MQTTControlPlane"]
    WATCHDOG["watchdog: BasePipelineWatchDog"]
    PIPELINE["pipeline: InferencePipeline"]
  end

  %% --- Command Handlers ---
  subgraph "Command Handlers"
    H_PAUSE["_handle_pause()"]
    H_RESUME["_handle_resume()"]
    H_STOP["_handle_stop()"]
    H_STATUS["_handle_status()"]
    H_METRICS["_handle_metrics()"]
    H_TOGGLE["_handle_toggle_crop()"]
    H_STATS["_handle_stabilization_stats()"]
  end

  %% --- State Tracking ---
  subgraph "State Tracking"
    SHUTDOWN["shutdown_event: Event"]
    RUNNING["is_running: bool"]
  end

  %% --- Other delegated creations ---
  BUILDER["builder: PipelineBuilder"]
  HANDLER["inference_handler: InferenceHandler"]
  ROI["roi_state: ROIState"]
  STAB["stabilizer: DetectionStabilizer"]

  %% Wiring: config -> init -> builder
  CONFIG --> INIT
  INIT --> BUILDER

  %% setup builds/attaches managed components
  SETUP --> DATA
  SETUP --> CONTROL
  SETUP --> WATCHDOG
  SETUP --> PIPELINE

  %% control plane routes commands to handlers
  CONTROL --> H_PAUSE
  CONTROL --> H_RESUME
  CONTROL --> H_STOP
  CONTROL --> H_STATUS
  CONTROL --> H_METRICS
  CONTROL --> H_TOGGLE
  CONTROL --> H_STATS

  %% builder creates via delegation
  BUILDER -. "Creates via delegation" .-> HANDLER
  BUILDER -. "Creates via delegation" .-> ROI
  BUILDER -. "Creates via delegation" .-> STAB
  BUILDER -. "Creates via delegation" .-> PIPELINE

  %% run/cleanup interactions
  RUN -. "Waits on" .-> SHUTDOWN
  CLEANUP -. "Disconnects" .-> CONTROL
  CLEANUP -. "Disconnects" .-> DATA
  CLEANUP -. "Terminates" .-> PIPELINE
end
```

**Separation of Concerns**: The controller owns lifecycle and orchestration. `PipelineBuilder` owns construction logic. Factories own instantiation details. This layered architecture prevents the controller from becoming a "God class" with too many responsibilities.

Sources: [adeline/app/controller.py58-91](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L58-L91) [adeline/CLAUDE.md67-88](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md#L67-L88)

## Lifecycle State Management



```mermaid
stateDiagram-v2
  [*] --> Initializing: **init**(config)
  Initializing --> SettingUp: setup()

  SettingUp --> DataPlaneReady: Configure MQTTDataPlane
  DataPlaneReady --> HandlerBuilt: Build InferenceHandler
  HandlerBuilt --> SinksBuilt: Build Sinks
  SinksBuilt --> StabilizationWrapped: Wrap with Stabilization
  StabilizationWrapped --> PipelineBuilt: Build InferencePipeline
  PipelineBuilt --> ControlPlaneReady: Configure MQTTControlPlane
  ControlPlaneReady --> Running: Auto-start pipeline

  Running --> Paused: PAUSE command
  Paused --> Running: RESUME command

  Running --> Stopping: STOP command
  Running --> Stopping: SIGINT/SIGTERM
  Paused --> Stopping: STOP command
  Paused --> Stopping: SIGINT/SIGTERM

  Stopping --> CleaningUp: cleanup()
  CleaningUp --> Terminated: pipeline.terminate()
  Terminated --> Disconnected: Disconnect planes
  Disconnected --> [*]

  %% failure path during setup
  SettingUp --> [*]: Setup failure
```

**Lifecycle Flow**: The controller progresses through distinct phases. Setup is sequential and fails fast if any step fails. Once running, the pipeline can transition between running and paused states via MQTT commands. Termination can be triggered by STOP command or OS signals, both leading to the same cleanup path.

Sources: [adeline/app/controller.py92-194](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L92-L194) [adeline/app/controller.py345-396](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L345-L396)

## Setup Process

The `setup()` method [adeline/app/controller.py92-194](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L92-L194) orchestrates initialization in seven sequential phases

### Setup Phase Breakdown



```mermaid
flowchart TD
  %% Start
  START([setup called]) --> DP_CREATE

  %% Phase 1
  subgraph P1[Phase 1: Configure Data Plane]
    DP_CREATE[MQTTDataPlane **init** ] --> DP_CONNECT[data_plane.connect timeout=10]
    DP_CONNECT --> DP_OK{Connection success?}
    DP_OK -- Yes --> DP_WATCH[data_plane.set_watchdog]
  end

  %% Fail fast on DP connect error
  DP_OK -- No --> FAIL[return False] --> END_FAIL([Setup failed])

  %% Phase 2
  subgraph P2[Phase 2: Build Inference Handler]
    DP_WATCH --> BUILD_H[builder.build_inference_handler]
    BUILD_H --> STORE_H[Store: self.inference_handler, self.roi_state]
  end

  %% Phase 3
  subgraph P3[Phase 3: Build Sinks]
    STORE_H --> BUILD_SINKS[builder.build_sinks data_plane, roi_state, handler]
    BUILD_SINKS --> STORE_SINKS[Store: sinks list]
  end

  %% Phase 4
  subgraph P4[Phase 4: Wrap Stabilization]
    STORE_SINKS --> STAB_Q{STABILIZATION_MODE != 'none'?}
    STAB_Q -- Yes --> WRAP_SINKS[builder.wrap_sinks_with_stabilization sinks] --> STORE_STAB[Store: self.stabilizer]
    STAB_Q -- No  --> STAB_NONE[self.stabilizer = None]
  end

  %% Phase 5
  subgraph P5[Phase 5: Build Pipeline]
    STORE_STAB --> BUILD_PIPE
    STAB_NONE  --> BUILD_PIPE
    BUILD_PIPE[builder.build_pipeline handler, sinks, watchdog, status_handler] --> STORE_PIPE[Store: self.pipeline]
  end

  %% Phase 6
  subgraph P6[Phase 6: Configure Control Plane]
    STORE_PIPE --> CP_CREATE[MQTTControlPlane **init**]
    CP_CREATE --> CP_REGISTER[_setup_control_callbacks]
    CP_REGISTER --> CP_CONNECT[control_plane.connect timeout=10]
    CP_CONNECT --> CP_OK{Connection success?}
  end

  %% Fail on CP connect error
  CP_OK -- No --> FAIL
  %% Proceed if CP connects
  CP_OK -- Yes --> P7

  %% Phase 7
  subgraph P7[Phase 7: Auto-start Pipeline]
    PIPE_START[self.pipeline.start] --> PIPE_EX{Exception?}
    PIPE_EX -- Yes --> FAIL
    PIPE_EX -- No  --> RUNNING[self.is_running = True] --> SUCCESS[return True]
  end

  %% Terminals
  SUCCESS --> END_OK([Setup complete])
  END_OK --> END
  END_FAIL --> END
  END([End])
```


**Fail-Fast Design**: Each phase checks for errors before proceeding. MQTT connections have 10-second timeouts [adeline/app/controller.py120-176](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L120-L176) If any phase fails, the method returns `False` immediately, preventing partial initialization.

**Order Dependencies**:

- Data Plane must be ready before building sinks (sinks need MQTT publisher)
- Handler must exist before building sinks (ROI update sink needs handler reference)
- Sinks must be built before stabilization wrapping (stabilizer wraps first sink)
- Control Plane is configured last (after all components exist for command handling)

Sources: [adeline/app/controller.py92-194](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L92-L194)

## Command Registration System

The controller uses `CommandRegistry` for explicit, type-safe command registration. Commands are registered conditionally based on system capabilities:

### Command Registration Logic



```mermaid
flowchart TD
  START[_setup_control_callbacks] --> REG
  REG[registry = control_plane.command_registry] --> BASIC[Register Basic Commands]

  BASIC --> R_PAUSE[registry.register 'pause' _handle_pause]
  R_PAUSE --> R_RESUME[registry.register 'resume' _handle_resume]
  R_RESUME --> R_STOP[registry.register 'stop' _handle_stop]
  R_STOP --> R_STATUS[registry.register 'status' _handle_status]
  R_STATUS --> R_METRICS[registry.register 'metrics' _handle_metrics]

  R_METRICS --> CHECK_TOGGLE{inference_handler and handler.supports_toggle}
  CHECK_TOGGLE -- Yes --> R_TOGGLE[registry.register 'toggle_crop' _handle_toggle_crop]
  CHECK_TOGGLE -- No --> SKIP_TOGGLE[Log toggle_crop not available]

  R_TOGGLE --> CHECK_STAB
  SKIP_TOGGLE --> CHECK_STAB
  CHECK_STAB{self.stabilizer is not None}
  CHECK_STAB -- Yes --> R_STAB[registry.register 'stabilization_stats' _handle_stabilization_stats]
  CHECK_STAB -- No --> SKIP_STAB[Skip stabilization_stats]

  R_STAB --> DONE[Registration Complete]
  SKIP_STAB --> DONE
```


**Conditional Registration**: Commands are only registered if the system supports them. This prevents runtime errors when users send commands that the current configuration doesn't support.

|Command|Always Available?|Condition|
|---|---|---|
|`pause`|✓ Yes|-|
|`resume`|✓ Yes|-|
|`stop`|✓ Yes|-|
|`status`|✓ Yes|-|
|`metrics`|✓ Yes|-|
|`toggle_crop`|✗ Conditional|`handler.supports_toggle == True`|
|`stabilization_stats`|✗ Conditional|`STABILIZATION_MODE != 'none'`|

Sources: [adeline/app/controller.py196-219](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L196-L219) [adeline/control/registry.py28-142](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/control/registry.py#L28-L142)

### Command Handler Implementation

Each command handler follows a consistent pattern:

**PAUSE Handler** [adeline/app/controller.py246-257](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L246-L257):

```
# Checks is_running flag
# Calls pipeline.pause_stream()
# Publishes status via control_plane
```

**RESUME Handler** [adeline/app/controller.py259-270](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L259-L270):

```
# Checks is_running flag
# Calls pipeline.resume_stream()
# Publishes status via control_plane
```

**STOP Handler** [adeline/app/controller.py228-244](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L228-L244):

```
# Calls pipeline.terminate()
# Sets is_running = False
# Publishes status
# Sets shutdown_event to trigger cleanup
```

**STATUS Handler** [adeline/app/controller.py272-276](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L272-L276):

```
# Returns current is_running state
# Publishes via control_plane
```

**METRICS Handler** [adeline/app/controller.py278-284](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L278-L284):

```
# Delegates to data_plane.publish_metrics()
# Publishes watchdog metrics via MQTT
```

**TOGGLE_CROP Handler** [adeline/app/controller.py286-307](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L286-L307):

```
# Validates handler.supports_toggle
# Calls handler.disable() or handler.enable()
# Uses handler's built-in toggle logic
```

**STABILIZATION_STATS Handler** [adeline/app/controller.py308-343](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L308-L343):

```
# Validates STABILIZATION_MODE != 'none'
# Calls stabilizer.get_stats(source_id=0)
# Logs statistics breakdown
```

Sources: [adeline/app/controller.py228-343](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L228-L343)

## Signal Handling and Graceful Shutdown

The controller implements proper signal handling for graceful termination:



```mermaid
sequenceDiagram
  actor User
  participant OS
  participant Controller as InferencePipelineController
  participant Pipeline as InferencePipeline
  participant ControlPlane as MQTTControlPlane
  participant DataPlane as MQTTDataPlane

  Note over Controller: run loop detects shutdown_event
  User->>OS: Ctrl+C SIGINT
  OS->>Controller: _signal_handler SIGINT
  Controller->>Controller: shutdown_event.set
  Controller->>Pipeline: terminate
  Controller->>Controller: is_running False
  Controller->>Controller: cleanup

  alt Pipeline Still Running
    Controller->>Pipeline: terminate
    Controller->>Pipeline: join timeout 10.0
    Pipeline-->>Controller: thread joined
  end

  Controller->>Pipeline: disconnect
  Controller->>ControlPlane: publish_status disconnected
  ControlPlane->>ControlPlane: client.loop_stop
  ControlPlane-->>Controller: disconnected

  Controller->>DataPlane: get_stats
  DataPlane-->>Controller: statistics
  Controller->>DataPlane: disconnect
  DataPlane-->>Controller: disconnected

  Controller-->>User: exit 0
```

**Signal Handler** [adeline/app/controller.py385-396](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L385-L396):

- Registered for SIGINT (Ctrl+C) and SIGTERM
- Sets `shutdown_event` to break `run()` loop
- Immediately terminates pipeline
- Sets `is_running = False`

**Run Loop** [adeline/app/controller.py345-383](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L345-L383):

- Calls `setup()` and validates success
- Logs available commands and configuration
- Waits on `shutdown_event` with 1-second timeout (allows interrupt checking)
- Catches `KeyboardInterrupt` as fallback
- Calls `cleanup()` on exit

**Cleanup Process** [adeline/app/controller.py398-443](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L398-L443):

1. Terminates pipeline if still running
2. Waits for pipeline threads with 10-second timeout (increased from 3s)
3. Disconnects Control Plane (publishes "disconnected" status)
4. Gets Data Plane stats and logs them
5. Disconnects Data Plane
6. Returns normally (no `os._exit()` to allow Python cleanup)

**Improved Reliability**: The cleanup timeout was increased from 3 seconds to 10 seconds [adeline/app/controller.py418](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L418-L418) to handle slow network disconnections. Error handling wraps each disconnect operation to ensure partial cleanup on failures.

Sources: [adeline/app/controller.py345-443](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L345-L443) [adeline/CLAUDE.md65-88](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md#L65-L88)

## Main Entry Point

The `main()` function [adeline/app/controller.py449-500](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L449-L500) provides the application entry point:

### Configuration Loading Flow



```mermaid
flowchart TD
  START[main entry] --> LOAD_ENV[load_dotenv]
  LOAD_ENV --> CONFIG_PATH[config_path = 'config/adeline/config.yaml']
  CONFIG_PATH --> PATH_CHECK{config file exists?}
  PATH_CHECK -->|Yes| LOAD_YAML[AdelineConfig.from_yaml config_path]
  PATH_CHECK -->|No| DEFAULTS[AdelineConfig with defaults]
  LOAD_YAML --> VALIDATE{Pydantic validation}
  VALIDATE -->|ValidationError| PRINT_ERRORS[Print validation errors]
  PRINT_ERRORS --> EXIT_1[sys.exit 1]
  VALIDATE -->|Success| CONVERT[config = pydantic_config.to_legacy_config]
  DEFAULTS --> CONVERT
  CONVERT --> LOGGING[Configure logging with config.LOG_LEVEL]
  LOGGING --> PAHO[Set paho-mqtt log level]
  PAHO --> CREATE[controller = InferencePipelineController config]
  CREATE --> RUN_TRY[try controller.run]
  RUN_TRY --> RUN_CATCH{Exception?}
  RUN_CATCH -->|Yes| LOG_ERROR[logger.error with traceback]
  LOG_ERROR --> EXIT_2[sys.exit 1]
  RUN_CATCH -->|No| EXIT_OK[Normal exit]
```

**Fail-Fast Validation**: Configuration is validated at load time using Pydantic. Invalid configurations print clear error messages showing which fields failed validation and why [adeline/app/controller.py467-474](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L467-L474) This prevents runtime errors from misconfiguration.

**Environment Variables**: The `load_dotenv()` call [adeline/app/controller.py19](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L19-L19) loads sensitive values (MQTT credentials) from `.env` file before configuration parsing.

**Logging Configuration**: Log levels are set from configuration [adeline/app/controller.py480-483](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L480-L483) including reduced verbosity for the `paho-mqtt` library [adeline/app/controller.py490](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L490-L490)

Sources: [adeline/app/controller.py449-503](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L449-L503) [adeline/config/schemas.py1-250](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/config/schemas.py#L1-L250)

## Component Interaction Map

This diagram bridges natural language concepts to code entities by showing exact class and method names:



```mermaid
flowchart TD
  IPC[InferencePipelineController]
  PB[PipelineBuilder]
  MCP[MQTTControlPlane]
  REG[CommandRegistry]
  MDP[MQTTDataPlane]
  IP[InferencePipeline]

  IPC_SETUP[setup]
  IPC_RUN[run]
  IPC_CLEANUP[cleanup]
  IPC_SIGNAL[_signal_handler]
  IPC_PAUSE[_handle_pause]
  IPC_RESUME[_handle_resume]
  IPC_STOP[_handle_stop]
  IPC_TOGGLE[_handle_toggle_crop]

  PB_HANDLER[build_inference_handler]
  PB_SINKS[build_sinks]
  PB_WRAP[wrap_sinks_with_stabilization]
  PB_PIPELINE[build_pipeline]

  MCP_CONNECT[connect]
  MCP_ON_MSG[_on_message]
  MCP_PUB_STATUS[publish_status]

  REG_REGISTER[register]
  REG_EXECUTE[execute]

  MDP_CONNECT[connect]
  MDP_METRICS[publish_metrics]

  IP_START[start]
  IP_PAUSE[pause_stream]
  IP_RESUME[resume_stream]
  IP_TERMINATE[terminate]
  IP_JOIN[join]

  IPC --> IPC_SETUP
  IPC --> IPC_RUN
  IPC --> IPC_CLEANUP
  IPC --> IPC_SIGNAL
  IPC --> IPC_PAUSE
  IPC --> IPC_RESUME
  IPC --> IPC_STOP
  IPC --> IPC_TOGGLE

  IPC_SETUP --> PB
  PB --> PB_HANDLER
  PB --> PB_SINKS
  PB --> PB_WRAP
  PB --> PB_PIPELINE

  IPC_SETUP --> MCP_CONNECT
  IPC_SETUP --> MDP_CONNECT
  IPC_SETUP --> IP_START

  MCP --> MCP_CONNECT
  MCP --> MCP_ON_MSG
  MCP --> MCP_PUB_STATUS
  MCP --> REG
  MCP_ON_MSG --> REG_EXECUTE

  REG --> REG_REGISTER
  REG --> REG_EXECUTE
  REG_EXECUTE --> IPC_PAUSE
  REG_EXECUTE --> IPC_RESUME
  REG_EXECUTE --> IPC_STOP
  REG_EXECUTE --> IPC_TOGGLE

  MDP --> MDP_CONNECT
  MDP --> MDP_METRICS

  IPC_PAUSE --> IP_PAUSE
  IPC_RESUME --> IP_RESUME
  IPC_STOP --> IP_TERMINATE
  IPC_CLEANUP --> IP_TERMINATE
  IPC_CLEANUP --> IP_JOIN

  IP --> IP_START
  IP --> IP_PAUSE
  IP --> IP_RESUME
  IP --> IP_TERMINATE
  IP --> IP_JOIN
```


**Code Navigation**: This diagram shows the exact method calls between components. To trace command execution: `MQTTControlPlane._on_message()` → `CommandRegistry.execute()` → `InferencePipelineController._handle_*()` methods → `InferencePipeline.pause_stream()` / `resume_stream()` / `terminate()`.

Sources: [adeline/app/controller.py58-503](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L58-L503) [adeline/app/builder.py1-200](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/builder.py#L1-L200) [adeline/control/plane.py26-172](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/control/plane.py#L26-L172) [adeline/control/registry.py28-142](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/control/registry.py#L28-L142)

## Key Design Patterns

The controller implements several design patterns:

|Pattern|Implementation|Benefit|
|---|---|---|
|**Builder**|Delegates construction to `PipelineBuilder`|Separates construction complexity from orchestration|
|**Registry**|Uses `CommandRegistry` for command handling|Explicit command registration, no optional callbacks|
|**Observer**|`_status_update_handler` for pipeline events|Decouples status monitoring from main logic|
|**Event-Driven**|`shutdown_event` for coordination|Clean thread synchronization without polling|
|**Fail-Fast**|Validation in `setup()` and `main()`|Errors detected early, not during runtime|

**Single Responsibility**: The controller orchestrates but doesn't construct. It manages lifecycle but doesn't know implementation details. This follows the "Complexity by design, not by accident" philosophy [adeline/CLAUDE.md59](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md#L59-L59) by using architectural boundaries to manage complexity.

Sources: [adeline/app/controller.py58-503](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L58-L503) [adeline/CLAUDE.md56-150](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/CLAUDE.md#L56-L150)

## Configuration Dependencies

The controller requires these configuration values from `PipelineConfig`:

**MQTT Settings**:

- `MQTT_BROKER`, `MQTT_PORT` - Broker connection details
- `MQTT_USERNAME`, `MQTT_PASSWORD` - Authentication credentials
- `CONTROL_COMMAND_TOPIC`, `CONTROL_STATUS_TOPIC` - Control Plane topics
- `DATA_TOPIC`, `METRICS_TOPIC` - Data Plane topics
- `DATA_QOS` - Quality of service level for data publishing

**Pipeline Settings**:

- `ROI_MODE` - Determines if `toggle_crop` command is available
- `STABILIZATION_MODE` - Determines if `stabilization_stats` command is available

**Logging Settings**:

- `LOG_LEVEL` - Application log level
- `LOG_FORMAT` - Log message format
- `PAHO_LOG_LEVEL` - MQTT library log level

For complete configuration schema details, see [Configuration System](https://deepwiki.com/acare7/kata-inference-251021-clean4/6-configuration-system) and [Configuration Schema Reference](https://deepwiki.com/acare7/kata-inference-251021-clean4/6.1-configuration-schema-reference).

Sources: [adeline/app/controller.py73-91](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/app/controller.py#L73-L91) [adeline/config/schemas.py1-250](https://github.com/acare7/kata-inference-251021-clean4/blob/a0662727/adeline/config/schemas.py#L1-L250)