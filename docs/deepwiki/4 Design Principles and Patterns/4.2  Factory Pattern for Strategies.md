# Factory Pattern for Strategies

Relevant source files

- [adeline/CLAUDE.md](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md)
- [adeline/DESIGN.md](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md)
- [adeline/config.py](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py)

## Purpose and Scope

This document explains the factory pattern implementation used throughout the Adeline inference system to enable configuration-driven behavior selection. The system uses factory functions to instantiate strategy objects for ROI (Region of Interest) processing and detection stabilization, allowing runtime behavior modification without code changes.

For detailed configuration options, see [Configuration Reference](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/6-configuration-reference). For implementation guidance on adding new strategies, see [Extending with New Strategies](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/8.3-extending-with-new-strategies). For the broader architectural context of configuration-driven design, see [Configuration-Driven Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.1-configuration-driven-architecture).

---

## Factory Pattern Overview

The factory pattern abstracts object creation behind a function that selects and instantiates the appropriate implementation based on configuration. This pattern is central to the system's "complexity by design" philosophy: complexity lives in the architecture and configuration, not in conditional logic scattered throughout the codebase.

### Why Factory Pattern Here

The factory pattern enables:

- **Configuration-driven behavior**: Change pipeline behavior by editing `config.yaml` without recompiling
- **Runtime flexibility**: Switch strategies via MQTT commands during operation
- **Easy extensibility**: Add new strategies without modifying existing code
- **Testability**: Each strategy can be tested in isolation
- **Separation of concerns**: Strategy selection logic is centralized in factory functions

**Factory Pattern Workflow**: Configuration flows from YAML to factory functions, which instantiate concrete strategy implementations. The pipeline uses these strategies polymorphically without knowing their concrete types.

Sources: [adeline/DESIGN.md24-36](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L24-L36) [adeline/CLAUDE.md58-69](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L58-L69) [Diagram 2](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%202#LNaN-LNaN)

---

## ROI Strategy Factory

The ROI (Region of Interest) strategy factory creates objects that determine which portion of each frame to process through the inference model. This is a performance optimization: by processing only relevant regions, inference speed increases.

### Factory Function Signature

Location: `inference/roi/__init__.py`

The factory function `create_roi_strategy()` examines the `roi_strategy.mode` configuration value and instantiates the corresponding strategy class.

### Strategy Modes

|Mode|Implementation|Purpose|Configuration Parameters|
|---|---|---|---|
|`none`|`NoneROIStrategy`|Process full frame|None|
|`adaptive`|`AdaptiveROIStrategy`|Dynamic crop based on detections|`margin`, `smoothing`, `min_roi_multiple`, `max_roi_multiple`|
|`fixed`|`FixedROIStrategy`|Static predefined region|`x_min`, `y_min`, `x_max`, `y_max`|

### Configuration Structure

```
roi_strategy:
  mode: adaptive  # none | adaptive | fixed
  
  adaptive:
    margin: 0.2              # Expand detection bounding box by 20%
    smoothing: 0.3           # Temporal smoothing factor (0.0-1.0)
    min_roi_multiple: 1      # Minimum ROI size as multiple of model input
    max_roi_multiple: 4      # Maximum ROI size as multiple of model input
    show_statistics: true    # Display ROI metrics
    resize_to_model: false   # Resize crop to model dimensions
  
  fixed:
    x_min: 0.2              # Left edge (normalized 0.0-1.0)
    y_min: 0.2              # Top edge (normalized 0.0-1.0)
    x_max: 0.8              # Right edge (normalized 0.0-1.0)
    y_max: 0.8              # Bottom edge (normalized 0.0-1.0)
    show_overlay: true      # Draw ROI rectangle on output
    resize_to_model: false  # Resize crop to model dimensions
```

### Strategy Interface Pattern

Each ROI strategy implements a common interface, allowing the pipeline to treat them polymorphically:

**ROI Strategy Polymorphism**: The pipeline depends on the `ROIStrategy` interface, not concrete implementations. The factory function handles instantiation.

Sources: [adeline/CLAUDE.md58-62](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L58-L62) [adeline/config.py149-200](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L149-L200) [Diagram 2](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%202#LNaN-LNaN)

### Adaptive ROI Details

The `AdaptiveROIStrategy` implements dynamic cropping with temporal smoothing:

1. **Initial State**: Processes full frame until first detection
2. **Detection Update**: Computes bounding box encompassing all detections
3. **Margin Expansion**: Expands bounding box by configured margin (e.g., 20%)
4. **Temporal Smoothing**: Applies exponential moving average to ROI coordinates to prevent jittery crops
5. **Size Constraints**: Enforces minimum/maximum ROI size relative to model input dimensions
6. **Frame Cropping**: Crops next frame to computed ROI before inference

This creates a feedback loop where detections influence the next frame's processed region, reducing computation while maintaining detection coverage.

### Fixed ROI Details

The `FixedROIStrategy` applies a static crop to every frame:

1. Normalized coordinates define the region (0.0 to 1.0 in both dimensions)
2. Same crop applied to every frame regardless of detections
3. Optional visualization overlay showing the ROI boundary
4. Useful for scenarios with known camera placement and regions of interest

Sources: [adeline/config.py149-176](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L149-L176) [adeline/CLAUDE.md58-62](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L58-L62)

---

## Stabilization Strategy Factory

The stabilization strategy factory creates objects that filter detection results to reduce flickering. Without stabilization, small or fast-moving objects may appear and disappear frame-to-frame, creating a flicker effect in the output.

### Factory Function Signature

Location: `inference/stabilization/core.py`

The factory function `create_stabilization_strategy()` examines the `detection_stabilization.mode` configuration value and instantiates the corresponding stabilizer.

### Strategy Modes

|Mode|Implementation|Purpose|Key Parameters|
|---|---|---|---|
|`none`|`NoneStabilizationStrategy`|No filtering (pass-through)|None|
|`temporal`|`TemporalHysteresisStrategy`|Require consecutive frames + dual thresholds|`min_frames`, `max_gap`, `appear_confidence`, `persist_confidence`|

### Configuration Structure

```
detection_stabilization:
  mode: temporal  # none | temporal
  
  temporal:
    min_frames: 3              # Require N consecutive frames to confirm
    max_gap: 2                 # Allow N frame gaps before removing
  
  hysteresis:
    appear_confidence: 0.5     # High threshold to appear
    persist_confidence: 0.3    # Low threshold to persist
```

### Temporal + Hysteresis Strategy

**Stabilization State Machine**: Detections transition through states based on consecutive frame counts and dual confidence thresholds.

Sources: [adeline/CLAUDE.md64-69](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L64-L69) [adeline/config.py134-148](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L134-L148)

### Hysteresis Mechanism

The temporal strategy uses **dual thresholds** to prevent flickering:

1. **Appear Threshold** (high, e.g., 0.5): New detections must exceed this confidence for `min_frames` consecutive frames to appear
2. **Persist Threshold** (low, e.g., 0.3): Existing detections only need this confidence to remain visible
3. **Gap Tolerance**: Detections can disappear for up to `max_gap` frames before being removed

This creates hysteresis: it's harder for a detection to appear than to persist. This asymmetry reduces flicker caused by marginal detections that hover around a single threshold.

### Stabilization Statistics

The `TemporalHysteresisStrategy` tracks internal statistics accessible via MQTT command:

```
{
  "command": "stabilization_stats"
}
```

Response includes:

- Number of objects currently tracked
- Candidate objects (not yet confirmed)
- Frame gaps per tracked object
- Consecutive frame counts

Sources: [adeline/CLAUDE.md64-69](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L64-L69) [adeline/config.py134-148](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L134-L148)

---

## Configuration-Driven Strategy Selection

Both factory functions are invoked during system initialization, with their behavior determined entirely by configuration values. This separation of "what to do" (configuration) from "how to do it" (code) is fundamental to the system's design.

### Initialization Sequence

**Configuration to Strategy Instantiation**: The controller loads configuration, invokes factory functions, and passes strategy instances to the pipeline.

Sources: [adeline/config.py56-206](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L56-L206) [Diagram 5](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%205#LNaN-LNaN)

### Configuration Loading Pattern

The `PipelineConfig` class centralizes configuration loading from multiple sources:

|Source|Purpose|Examples|
|---|---|---|
|`.env`|Sensitive credentials|`ROBOFLOW_API_KEY`, `MQTT_USERNAME`, `MQTT_PASSWORD`|
|`config.yaml`|Application settings|Strategy modes, thresholds, RTSP URLs|
|Environment variables|Runtime overrides|Can override YAML values|

Configuration values are read once during initialization and passed to factory functions. This makes the system's behavior deterministic and traceable: inspect the configuration to understand what strategies are active.

Sources: [adeline/config.py1-206](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L1-L206) [Diagram 2](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%202#LNaN-LNaN)

### Backward Compatibility

The configuration system supports legacy configuration formats:

```
# Legacy format (deprecated)
adaptive_crop:
  enabled: true
  margin: 0.2

# New format (preferred)
roi_strategy:
  mode: adaptive
  adaptive:
    margin: 0.2
```

The `PipelineConfig` class detects legacy format and emits a warning, converting to the new internal representation. This enables migration without breaking existing deployments.

Sources: [adeline/config.py177-205](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/config.py#L177-L205)

---

## Runtime Strategy Control

While strategies are selected at startup via configuration, some aspects can be modified at runtime through MQTT commands. This enables dynamic behavior adjustment without restarting the pipeline.

### MQTT Control Integration

**Runtime Strategy Control Flow**: MQTT commands flow through the control plane to modify strategy behavior without restarting.

Sources: [adeline/CLAUDE.md27-31](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L27-L31) [Diagram 4](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%204#LNaN-LNaN)

### Available Runtime Commands

|Command|Target|Effect|Limitation|
|---|---|---|---|
|`toggle_crop`|ROI Strategy|Enable/disable adaptive or fixed cropping|Only if ROI mode != `none`|
|`stabilization_stats`|Stabilization Strategy|Query tracking statistics|Returns JSON with internal state|

Example command:

```
{"command": "toggle_crop"}
```

Example response:

```
{
  "status": "success",
  "crop_enabled": false,
  "message": "Adaptive crop disabled"
}
```

### Runtime Limitations

Not all strategy aspects can be changed at runtime:

**Cannot Change at Runtime**:

- Strategy mode (e.g., `adaptive` → `fixed`)
- Strategy parameters (e.g., margin, smoothing factor)
- Switching between stabilization algorithms

**Can Change at Runtime**:

- Enable/disable current ROI strategy
- Query stabilization statistics

To change modes or parameters, modify `config.yaml` and restart the pipeline. This is intentional: the factory pattern instantiates strategies once during initialization. Runtime parameter changes would require implementing mutable strategy state, adding complexity.

Sources: [adeline/CLAUDE.md27-31](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L27-L31) [adeline/CLAUDE.md62](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L62-L62)

---

## Extensibility

The factory pattern makes adding new strategies straightforward. New implementations follow the same interface as existing strategies, and the factory function gains one additional conditional branch.

### Adding a New ROI Strategy

**Example: Grid ROI Strategy** (divides frame into grid cells)

1. **Create Implementation**: `inference/roi/grid.py`
    
    - Implement `process_frame(frame)` method
    - Implement `update_roi(detections)` method
    - Follow existing strategy interface
2. **Update Factory Function**: `inference/roi/__init__.py`
    
    ```
    def create_roi_strategy(mode: str, config: PipelineConfig):
        if mode == "none":
            return NoneROIStrategy()
        elif mode == "adaptive":
            return AdaptiveROIStrategy(...)
        elif mode == "fixed":
            return FixedROIStrategy(...)
        elif mode == "grid":  # New strategy
            return GridROIStrategy(...)
        else:
            raise ValueError(f"Unknown ROI mode: {mode}")
    ```
    
3. **Add Configuration Section**: `config.yaml`
    
    ```
    roi_strategy:
      mode: grid
      grid:
        rows: 3
        cols: 3
        active_cells: [0, 4, 8]  # Process corners and center
    ```
    
4. **Update Config Class**: `adeline/config.py`
    
    - Add configuration attributes for grid parameters
    - Parse `grid` section from YAML

No changes required to:

- `InferencePipeline` (uses strategy polymorphically)
- `InferencePipelineController` (orchestrates without knowledge of concrete types)
- MQTT planes (operate independently of strategy details)

### Adding a New Stabilization Strategy

**Example: Kalman Filter Stabilization** (predict object trajectories)

1. **Create Implementation**: `inference/stabilization/kalman.py`
    
    - Implement stabilization interface
    - Maintain Kalman filter state per tracked object
2. **Update Factory Function**: `inference/stabilization/core.py`
    
    - Add `elif mode == "kalman":` branch
    - Instantiate with configuration parameters
3. **Add Configuration**: `config.yaml`
    
    ```
    detection_stabilization:
      mode: kalman
      kalman:
        process_noise: 0.01
        measurement_noise: 0.1
    ```
    
4. **Update Config Class**: Parse kalman parameters
    

### Strategy Interface Contract

All strategies must implement their respective interfaces:

**ROI Strategy Interface**:

- `process_frame(frame: np.ndarray) -> np.ndarray`: Transform input frame
- `update_roi(detections: List[Detection]) -> None`: Update internal state based on detections

**Stabilization Strategy Interface**:

- `stabilize(detections: List[Detection]) -> List[Detection]`: Filter detection list
- Optional: `get_statistics() -> Dict`: Return internal metrics

Following these contracts ensures new strategies integrate seamlessly with the existing pipeline.

Sources: [adeline/DESIGN.md24-36](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L24-L36) [adeline/CLAUDE.md96-125](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L96-L125)

---

## Key Takeaways

|Aspect|Implementation|
|---|---|
|**Strategy Selection**|Configuration-driven via `mode` parameter in YAML|
|**Factory Functions**|`create_roi_strategy()`, `create_stabilization_strategy()`|
|**Polymorphism**|Pipeline uses interface, not concrete types|
|**Runtime Control**|Limited MQTT commands for enable/disable and statistics|
|**Extensibility**|Add new strategy → Update factory → Add config → Done|
|**Initialization**|Strategies instantiated once at startup|

The factory pattern enables the system's "complexity by design" philosophy: adding new behavior requires adding new classes and configuration, not modifying existing code. This reduces coupling, improves testability, and makes the system easier to reason about.

Sources: [adeline/DESIGN.md1-117](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L1-L117) [adeline/CLAUDE.md1-143](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L1-L143) [Diagram 2](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Diagram%202#LNaN-LNaN)