# Design Principles and Patterns

Relevant source files

- [adeline/CLAUDE.md](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md)
- [adeline/DESIGN.md](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md)

This document explains the core design philosophy, architectural patterns, and key implementation strategies used in the Adeline inference system. It covers the rationale behind major design decisions, how complexity is managed, and the patterns that enable flexibility and maintainability.  
For details on the high-level system architecture, see [System Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/3-system-architecture). For specifics on configuration, see [Configuration-Driven Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.1-configuration-driven-architecture). For component-level documentation, see [Core Components](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/5-core-components).

---

## Purpose and Scope

This page describes the guiding principles and recurring patterns that shape the Adeline codebase, including:

- Why the system is organized as it is ("complexity by design")
- How configuration, factories, and composition are used to manage variability
- The separation of control and data responsibilities
- The importance of initialization order
- Anti-patterns that are deliberately avoided

It is intended for developers and operators who want to understand the "why" behind the system's structure, not just the "how".

---

## 1. Complexity by Design

The Adeline system intentionally manages complexity through explicit architectural choices, not by writing complicated code. The goal is to make the system flexible, debuggable, and easy to extend, even if this means the architecture is more complex than a minimal implementation.

**Key Principles:**

- **Separation of Concerns:** Control and data responsibilities are split into distinct planes, each with its own guarantees and code modules.
- **Configuration-Driven Behavior:** All business logic is controlled by configuration, not hardcoded logic.
- **Factory Patterns:** Factories are used to instantiate variable strategies (e.g., ROI, stabilization) based on configuration.
- **Explicit Initialization Order:** Critical steps (like model disabling) are made explicit and ordered to avoid hidden side effects.
- **Composition Over Modification:** Output sinks are composed functionally, allowing new outputs to be added without modifying pipeline logic.

**Anti-Patterns Avoided:**

|Anti-Pattern|Why Avoided?|
|---|---|
|God objects|Prevents single points of failure/complexity|
|Hardcoded logic|Reduces flexibility and maintainability|
|Tight coupling|Enables independent scaling and testing|
|Magic initialization|Avoids hidden side effects|

**Sources:**  
[adeline/DESIGN.md1-117](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L1-L117) [adeline/CLAUDE.md95-117](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L95-L117)

---

### Diagram: "Design Principles to Code Entities Mapping"

**Sources:**  
[adeline/CLAUDE.md27-92](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L27-L92) [adeline/DESIGN.md9-73](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L9-L73)

---

## 2. Control/Data Plane Separation

The system is architected around a strict separation between the control plane and the data plane:

- **Control Plane:** Handles commands (pause, resume, stop, status, etc.) with reliable delivery (MQTT QoS 1). Implemented in `control/plane.py` as `MQTTControlPlane`.
- **Data Plane:** Handles high-throughput detection results and metrics with best-effort delivery (MQTT QoS 0). Implemented in `data/plane.py` as `MQTTDataPlane`.

This separation ensures that control commands are always delivered reliably, while data throughput is maximized and not blocked by control traffic.

**Benefits:**

- Independent scaling and monitoring of control and data flows
- Predictable behavior under load
- Clear code boundaries

**Sources:**  
[adeline/CLAUDE.md27-38](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L27-L38) [adeline/DESIGN.md9-23](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L9-L23)

---

### Diagram: "Control/Data Plane Code Mapping"

**Sources:**  
[adeline/CLAUDE.md27-43](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L27-L43) [adeline/DESIGN.md11-23](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L11-L23)

---

## 3. Configuration-Driven Behavior

All runtime behavior is controlled by configuration files, not by hardcoded logic. This includes:

- Model selection and disabling
- ROI and stabilization strategy selection and parameters
- MQTT credentials and broker settings

**Key Mechanisms:**

- `.env` for secrets (API keys, credentials)
- `config.yaml` for pipeline and strategy settings
- Early validation and schema enforcement in `config.py`
- Disabling of heavy models before import via `disable_models_from_config()`

**Benefits:**

- Change system behavior without code changes or redeployment
- Safer, more auditable, and easier to operate

For more, see [Configuration-Driven Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.1-configuration-driven-architecture).

**Sources:**  
[adeline/CLAUDE.md44-55](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L44-L55) [adeline/DESIGN.md38-50](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L38-L50)

---

## 4. Factory Pattern for Strategies

The system uses the factory pattern to instantiate variable strategies for ROI (Region of Interest) and detection stabilization. Factories are selected and parameterized by configuration.

**ROI Strategies:**

- `none`: No cropping
- `adaptive`: Dynamic crop with temporal smoothing
- `fixed`: Static coordinates

**Stabilization Strategies:**

- `none`: No stabilization
- `temporal`: Temporal + hysteresis filtering

**Factory Functions:**

- `create_roi_strategy()` in `inference/roi/__init__.py`
- `create_stabilization_strategy()` in `inference/stabilization/core.py`

**Benefits:**

- Add new strategies without modifying pipeline code
- Decouple strategy selection from implementation

For more, see [Factory Pattern for Strategies](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.2-factory-pattern-for-strategies).

**Sources:**  
[adeline/CLAUDE.md58-125](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L58-L125) [adeline/DESIGN.md24-99](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L24-L99)

---

### Table: Example Factory Pattern Usage

|Strategy Type|Factory Function Location|Example Modes|Configuration Key|
|---|---|---|---|
|ROI|`inference/roi/__init__.py`|none, adaptive, fixed|`roi_strategy.mode`|
|Stabilization|`inference/stabilization/core.py`|none, temporal|`stabilization.mode`|

**Sources:**  
[adeline/CLAUDE.md58-125](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L58-L125) [adeline/DESIGN.md24-37](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L24-L37)

---

## 5. Explicit Initialization Order

A critical design pattern is the explicit ordering of initialization steps, especially for model management:

1. **Disable Unused Models:** `disable_models_from_config()` is called before importing the `inference` module. This prevents unnecessary loading of heavy models and avoids warnings.
2. **Import Inference Pipeline:** Only after disabling models is it safe to import and initialize the inference pipeline.

**Why?**  
Some model imports have side effects (e.g., loading large files or dependencies). Making the disabling step explicit and early prevents resource waste and startup errors.

**Sources:**  
[adeline/CLAUDE.md46-110](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L46-L110) [adeline/DESIGN.md51-106](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L51-L106)

---

### Diagram: "Initialization Sequence and Model Disabling"

**Sources:**  
[adeline/CLAUDE.md46-110](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L46-L110) [adeline/DESIGN.md51-106](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L51-L106)

---

## 6. Multi-Sink Composition

The output of the inference pipeline is directed to multiple destinations using a multi-sink pattern. This is implemented via the `multi_sink` function, which fans out predictions to any number of sinks (e.g., MQTT, OpenCV visualization, ROI state updates).

**Pattern Example:**

```
pipeline.on_prediction = multi_sink(
    create_mqtt_sink(...),
    create_visualization_sink(...)
)
```

_(See [inference/core/interfaces/stream/sinks.py](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/inference/core/interfaces/stream/sinks.py#LNaN-LNaN))_

**Benefits:**

- Add or remove output destinations without modifying pipeline logic
- Enables parallel output to remote systems, local displays, and internal state

For more, see [Multi-Sink Composition](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.3-multi-sink-composition).

**Sources:**  
[adeline/CLAUDE.md113-121](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L113-L121) [adeline/DESIGN.md63-73](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L63-L73)

---

### Diagram: "Multi-Sink Output Pattern"

**Sources:**  
[adeline/CLAUDE.md113-121](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/CLAUDE.md#L113-L121) [adeline/DESIGN.md63-73](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L63-L73)

---

## 7. Summary: Controlled Complexity

By applying these principles and patterns, Adeline achieves:

- Easy extensibility (add new strategies via factories)
- Flexible operation (change behavior via config)
- Clear separation for debugging and scaling
- Safe and predictable initialization
- Simple code, robust architecture

**Sources:**  
[adeline/DESIGN.md108-117](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/adeline/DESIGN.md#L108-L117)

---

## Further Reading

- [Configuration-Driven Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.1-configuration-driven-architecture)
- [Factory Pattern for Strategies](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.2-factory-pattern-for-strategies)
- [Multi-Sink Composition](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/4.3-multi-sink-composition)
- [System Architecture](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/3-system-architecture)
- [Core Components](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/5-core-components)