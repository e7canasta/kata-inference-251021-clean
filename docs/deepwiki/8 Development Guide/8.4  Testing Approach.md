# Testing Approach

Relevant source files

- [Makefile](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile)
- [README.md](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md)

## Purpose and Scope

This document explains the manual pair-programming testing methodology used in the Adeline inference system. Unlike traditional software projects that rely on automated unit tests, this project deliberately uses manual verification through integration testing to validate system behavior. This approach aligns with the project's design-first complexity management philosophy.

For information about extending the system with new features, see [Extending with New Strategies](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/8.3-extending-with-new-strategies). For operational monitoring and troubleshooting, see [Monitoring and Data Streams](https://deepwiki.com/care-foundation/kata-inference-251021-clean2/7.3-monitoring-and-data-streams).

---

## Testing Philosophy

The Adeline system follows a **manual pair-programming testing approach** rather than automated unit testing. This methodology is explicitly documented in the project and enforced through the development workflow.

### Core Principles

|Principle|Description|Implementation|
|---|---|---|
|Manual Verification|All functionality tested through hands-on execution|`make test` provides guided workflow|
|Integration Focus|Test complete system interactions, not isolated units|Test through MQTT control and data flows|
|Pair Programming|Two developers verify behavior together|Manual commands with real-time observation|
|Design-First|Refactor by design, not by test failure|Pre-planned architecture changes|

### Rationale

The system is complex by design, with multiple interacting components (control plane, data plane, inference pipeline, MQTT broker). Testing isolated units would not capture the emergent behavior of these interactions. The manual approach ensures:

1. **Real integration testing**: Components are tested as they actually run in production
2. **MQTT communication verification**: Control and data plane QoS strategies are validated under real conditions
3. **Observable behavior**: Developers directly observe detection output, stabilization, and ROI adaptation
4. **Configuration validation**: All configuration paths (adaptive ROI, stabilization modes, model selection) are tested in realistic scenarios

Sources: [README.md145-154](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L145-L154) [Makefile156-161](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L156-L161)

---

## Import Testing

Before manual verification, the system provides automated import testing to verify that all Python dependencies and module structures are correct. This prevents runtime import errors during manual testing.

### Import Test Command

```
make test-imports
```

This command executes a series of import statements to validate the module hierarchy:

```
from adeline import PipelineConfig
from adeline.control import MQTTControlPlane
from adeline.data import MQTTDataPlane
from adeline.inference.roi import ROIBox
from adeline.inference.stabilization import TemporalHysteresisStabilizer
```

### Import Dependency Map

**Purpose**: This diagram maps the `make test-imports` command to the specific Python modules and classes it validates, connecting the testing workflow to concrete code entities.

### What Import Testing Validates

|Validation|What It Checks|Why It Matters|
|---|---|---|
|Module structure|`adeline/__init__.py` exports work|Core package is importable|
|Control plane|`MQTTControlPlane` class loads|MQTT control dependencies present|
|Data plane|`MQTTDataPlane` class loads|MQTT data publishing works|
|ROI system|`ROIBox` dataclass available|ROI strategies can be instantiated|
|Stabilization|`TemporalHysteresisStabilizer` loads|Detection stabilization dependencies met|

Import testing does **not** validate:

- MQTT broker connectivity
- RTSP stream availability
- Model file existence
- Configuration file correctness

Sources: [Makefile163-170](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L163-L170)

---

## Manual Verification Workflow

The primary testing method is a structured manual workflow that exercises all system components through their intended interfaces. This workflow is codified in the `make test` command documentation.

### Standard Testing Sequence

**Purpose**: This sequence diagram shows the complete manual testing workflow, mapping each `make` command to the specific Python modules and MQTT topics involved in the operation.

### Testing Commands

|Command|Purpose|Expected Behavior|Verification Method|
|---|---|---|---|
|`make run`|Start inference pipeline|Pipeline initializes, connects to MQTT, starts processing|Observe console logs showing frame processing|
|`make pause`|Pause frame processing|Pipeline stops consuming frames, no new detections|Monitor stops showing new detection timestamps|
|`make resume`|Resume processing|Pipeline resumes frame consumption|New detections appear in monitor|
|`make monitor-data`|Watch detection stream|Real-time JSON output of detections|Visible detection data in terminal|
|`make metrics`|Request performance metrics|JSON with FPS, detection counts|Metrics JSON printed to console|
|`make status`|Query pipeline state|Current state (running/paused/stopped)|State message received|
|`make stop`|Graceful shutdown|Pipeline stops, cleans up, disconnects|Process exits cleanly (exit code 0)|

Sources: [README.md145-154](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L145-L154) [Makefile74-110](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L74-L110)

---

## Component-Specific Verification

Different system components require different verification approaches. This section maps each component to its testing methodology.

### Component Verification Map

**Purpose**: This diagram maps each major component to its specific verification methodology, showing how to manually test different aspects of the system.

### Configuration Validation

**What to Test**:

1. Configuration file syntax (YAML parsing)
2. Schema validation (required fields, types)
3. Environment variable loading
4. Model disabling mechanism

**Manual Test Procedure**:

```
# Test 1: Invalid YAML syntax
# Edit config/adeline/config.yaml, introduce syntax error
make run
# Expected: Clear error message indicating YAML parsing failed

# Test 2: Missing required field
# Remove 'rtsp_url' from config.yaml
make run
# Expected: Configuration validation error

# Test 3: Model disabling
# Add "yolo_nas" to models_disabled.disabled list
make run
# Expected: No ModelDependencyMissing warnings

# Test 4: ROI strategy switching
# Change roi_strategy.mode from "adaptive" to "fixed"
# Provide fixed coordinates
make run
# Expected: Pipeline uses fixed ROI (observable in visualization)
```

Sources: [README.md67-76](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L67-L76)

### Control Plane Testing

**What to Test**:

1. Command delivery (QoS 1 reliability)
2. Callback invocation
3. Status publishing
4. Connection resilience

**Manual Test Procedure**:

```
# Start pipeline
make run

# In separate terminal, rapid command sequence
make pause && sleep 1 && make resume && sleep 1 && make pause
# Expected: All commands executed in order, observable in logs

# Test signal handling
make run
# Press Ctrl+C
# Expected: Graceful shutdown, cleanup messages

# Test MQTT disconnect
make run
# Stop MQTT broker: make services-down
# Expected: Connection lost message, reconnect attempts

# Restart broker: make services-up
# Expected: Automatic reconnection
```

**Verification Points**:

- `InferencePipelineController.on_stop()` callback fires
- `InferencePipelineController.on_pause()` callback fires
- Pipeline state changes immediately
- Status updates published to `inference/control/status`

Sources: [Makefile84-110](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L84-L110)

### Data Plane Testing

**What to Test**:

1. Detection publishing (QoS 0 performance)
2. High-volume throughput
3. Message loss tolerance
4. Metric reporting

**Manual Test Procedure**:

```
# Start pipeline and monitor
make run
# In separate terminal:
make monitor-data --verbose

# Observe:
# - Detection messages arriving at high frequency
# - Timestamp monotonically increasing
# - Detection count per frame
# - Bounding box coordinates

# Test high load
# Edit config.yaml, set fps: 60
make run
make monitor-data
# Expected: Higher message rate, some possible loss (QoS 0)

# Test metrics request
make metrics
# Expected: JSON with:
# - fps (float)
# - total_detections (int)
# - detections_by_class (dict)
```

**Verification Points**:

- Monitor shows continuous stream of detection JSON
- High frame rates maintained (QoS 0 prioritizes throughput)
- Metrics endpoint responds with accurate counts

Sources: [Makefile115-125](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L115-L125)

### ROI Strategy Testing

**What to Test**:

1. Adaptive ROI calculation
2. Fixed ROI coordinates
3. Runtime toggle
4. Temporal smoothing

**Manual Test Procedure**:

```
# Test adaptive ROI
# Set config.yaml: roi_strategy.mode: "adaptive"
make run
# Observe visualization window
# Expected: Green ROI box following detected objects

# Test ROI parameters
# Edit config.yaml:
#   roi_strategy.adaptive.margin: 0.5
#   roi_strategy.adaptive.smoothing_factor: 0.7
make run
# Expected: Larger ROI margin, slower adaptation

# Test runtime toggle
make run
make toggle-crop
# Expected: ROI processing disabled (full frame used)
make toggle-crop
# Expected: ROI processing re-enabled

# Test fixed ROI
# Set config.yaml: roi_strategy.mode: "fixed"
#   roi_strategy.fixed.x_min: 100
#   roi_strategy.fixed.y_min: 100
#   roi_strategy.fixed.x_max: 500
#   roi_strategy.fixed.y_max: 500
make run
# Expected: Static ROI box at specified coordinates
```

**Verification Points**:

- `create_roi_strategy()` returns correct strategy instance
- Adaptive ROI tracks detections smoothly
- Fixed ROI remains constant
- Toggle command takes effect immediately

Sources: [Makefile104-106](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L104-L106)

### Stabilization Testing

**What to Test**:

1. Temporal hysteresis behavior
2. Threshold tuning
3. Detection persistence
4. Statistics reporting

**Manual Test Procedure**:

```
# Test stabilization
# Set config.yaml: stabilization.mode: "temporal"
make run
make monitor-data

# Observe detection IDs
# Expected: Detection IDs persist across frames
# No flickering of detections

# Test statistics
make stabilization-stats
# Expected: JSON with per-class statistics:
# - consecutive_frames_seen distribution
# - active/inactive detection counts

# Test thresholds
# Edit config.yaml:
#   stabilization.temporal.high_threshold: 0.7
#   stabilization.temporal.low_threshold: 0.4
#   stabilization.temporal.n_consecutive: 5
make run
# Expected: Higher threshold = stricter appearance
# More consecutive frames = less flickering

# Test disabled stabilization
# Set config.yaml: stabilization.mode: "none"
make run
make monitor-data
# Expected: Detections may flicker frame-to-frame
```

**Verification Points**:

- `TemporalHysteresisStabilizer` reduces detection flickering
- High threshold controls initial appearance
- Low threshold maintains presence once established
- Stats show frame persistence distribution

Sources: [Makefile108-110](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L108-L110)

---

## Integration Testing Scenarios

Integration testing verifies the complete system behavior with all components interacting.

### End-to-End Workflow

**Purpose**: This diagram shows the complete integration testing flow, exercising all system capabilities in sequence.

### Test Scenarios

#### Scenario 1: Cold Start to Steady State

**Steps**:

1. `make services-up` - Start MQTT broker
2. `make run` - Start pipeline
3. Verify console output shows:
    - Configuration loaded successfully
    - Models loaded (or disabled models skipped)
    - MQTT connections established (control QoS 1, data QoS 0)
    - Frame processing begins
4. `make monitor-data` - Verify detection stream
5. Observe steady-state behavior for 5 minutes
6. `make metrics` - Verify FPS and detection counts

**Expected Result**: System reaches steady state, maintains target FPS, publishes detections continuously.

#### Scenario 2: Dynamic Configuration Changes

**Steps**:

1. Start pipeline with adaptive ROI
2. `make toggle-crop` - Disable ROI
3. `make metrics` - Verify detection count increases (full frame)
4. `make toggle-crop` - Re-enable ROI
5. `make metrics` - Verify detection count returns to baseline

**Expected Result**: ROI toggle affects detection density without crashing pipeline.

#### Scenario 3: Signal Handling

**Steps**:

1. `make run` - Start pipeline
2. Press `Ctrl+C` (SIGINT)
3. Observe shutdown sequence:
    - "Received signal" message
    - Pipeline cleanup
    - MQTT disconnection
    - Process exits with code 0

**Expected Result**: Graceful shutdown with proper resource cleanup.

#### Scenario 4: Configuration Error Recovery

**Steps**:

1. Edit `config.yaml`, introduce invalid RTSP URL
2. `make run`
3. Observe error message
4. Fix configuration
5. `make run` again

**Expected Result**: Clear error messages guide user to fix configuration.

Sources: [README.md78-102](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L78-L102)

---

## Verification Checklist

Use this checklist to ensure comprehensive testing coverage.

### Pre-Deployment Verification

- [ ]  **Import Testing**: `make test-imports` passes
- [ ]  **Services Running**: `make services-status` shows MQTT broker active
- [ ]  **Configuration Valid**: Pipeline starts without validation errors
- [ ]  **Model Loading**: Check logs for "Model loaded" or "Model disabled" messages

### Pipeline Lifecycle

- [ ]  **Start**: `make run` starts successfully
- [ ]  **Pause**: `make pause` stops frame processing (observable in logs)
- [ ]  **Resume**: `make resume` restarts processing
- [ ]  **Stop**: `make stop` exits gracefully
- [ ]  **Signal Handling**: Ctrl+C triggers clean shutdown

### Data Flow

- [ ]  **Detection Publishing**: `make monitor-data` shows continuous stream
- [ ]  **Detection Content**: JSON contains bounding boxes, confidence, class names
- [ ]  **Metrics Reporting**: `make metrics` returns valid JSON with FPS
- [ ]  **Status Updates**: `make status` reports correct state

### Feature Testing

- [ ]  **Adaptive ROI**: Visualization shows green ROI box tracking objects
- [ ]  **Fixed ROI**: Static ROI box at configured coordinates
- [ ]  **ROI Toggle**: `make toggle-crop` switches ROI on/off
- [ ]  **Stabilization**: Detection IDs persist across frames
- [ ]  **Stabilization Stats**: `make stabilization-stats` returns meaningful data

### Error Handling

- [ ]  **Missing Config**: Clear error when `config.yaml` missing
- [ ]  **Invalid RTSP**: Readable error when stream unavailable
- [ ]  **MQTT Disconnect**: Pipeline attempts reconnection
- [ ]  **Invalid Command**: Unknown control commands ignored gracefully

### Performance

- [ ]  **Target FPS**: Pipeline maintains configured FPS under normal load
- [ ]  **Memory Stable**: Memory usage doesn't grow over time (30+ minute run)
- [ ]  **CPU Usage**: Reasonable CPU utilization for configured FPS
- [ ]  **MQTT QoS**: Control commands always delivered (QoS 1), data may drop under load (QoS 0)

Sources: [README.md145-162](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L145-L162) [Makefile156-170](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L156-L170)

---

## Troubleshooting Test Failures

### Common Issues and Resolution

|Symptom|Likely Cause|Resolution|Verification|
|---|---|---|---|
|Import errors on startup|Missing dependencies|`make install`|`make test-imports`|
|Pipeline hangs on start|MQTT broker not running|`make services-up`|`make services-status`|
|No detections in monitor|RTSP stream unavailable|Check `rtsp_url` in config|Verify stream with VLC|
|Commands not working|Control plane not subscribed|Check MQTT connection logs|`make status` should respond|
|High memory usage|Model loaded but disabled in config|Verify `disable_models_from_config()` called before imports|Check startup logs|
|Flickering detections|Stabilization disabled or too strict|Adjust `stabilization.mode` and thresholds|`make stabilization-stats`|
|ROI not adapting|Wrong strategy mode|Check `roi_strategy.mode` in config|Observe visualization|
|Metrics show 0 FPS|Pipeline paused|`make resume`|`make metrics` again|

### Debug Logging

Enable verbose logging for detailed troubleshooting:

```
# Edit config.yaml
logging:
  level: DEBUG  # Instead of INFO

make run
# Observe detailed logs for:
# - Frame processing timestamps
# - Detection counts per frame
# - MQTT publish confirmation
# - ROI calculations
# - Stabilization decisions
```

### MQTT Communication Debug

```
# Monitor all MQTT traffic
mosquitto_sub -h localhost -t 'inference/#' -v

# Expected topics:
# inference/control/commands - Control commands (QoS 1)
# inference/control/status - Status updates (QoS 1)
# inference/data/detections - Detection stream (QoS 0)
# inference/data/metrics - Performance metrics (QoS 0)
```

Sources: [README.md156-162](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L156-L162)

---

## Summary

The Adeline system uses a **manual pair-programming testing approach** that prioritizes integration testing over unit testing. This methodology aligns with the system's design philosophy: manage complexity through deliberate architecture rather than reactive test-driven refactoring.

**Key Testing Workflows**:

1. **Import testing**: `make test-imports` validates module structure
2. **Pipeline lifecycle**: Start, pause, resume, stop sequence
3. **Data monitoring**: `make monitor-data` observes real-time detections
4. **Control validation**: All control commands tested manually
5. **Feature verification**: ROI, stabilization, metrics tested through observation

**Testing Philosophy**: The absence of automated unit tests is intentional. The system's value comes from the interaction of its components (MQTT, inference, stabilization, ROI), which is best verified through end-to-end manual testing. The Makefile provides a structured workflow that serves as executable documentation of the testing process.

Sources: [README.md145-206](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/README.md#L145-L206) [Makefile156-170](https://github.com/care-foundation/kata-inference-251021-clean2/blob/9a713ffb/Makefile#L156-L170)